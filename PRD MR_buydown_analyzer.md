Below is a comprehensive Product Requirements Document (PRD) for an application that analyzes the cost-effectiveness of mortgage rate buydowns over time. This PRD is structured to guide you (and your team) through the planning, design, development, and deployment stages. Where appropriate, we include suggestions on how AI could be leveraged to simplify or enhance each step.

---

## 1. **Product Overview**

**Product Name**: Mortgage Rate Buydown Analyzer  
**Description**: A tool (web application or standalone script) that gathers mortgage-backed securities (MBS) price data for coupon rates ranging from 3% to 7.5%, calculates the relative value (ROI) of buying down mortgage interest rates in 10 or 25 basis point increments, and visualizes these findings over time.

**Primary Users**:
1. Mortgage professionals and advisors (to guide borrowers).
2. Borrowers and homeowners (to decide on paying discount points).
3. Investors interested in MBS yield behavior (to identify potential arbitrage or risk).

---

## 2. **Goals & Objectives**

1. **Accurate Data Sourcing**  
   - Retrieve (daily or weekly) MBS price data for coupon rates between 3% and 7.5%.

2. **Automated Calculations**  
   - Automatically compute cost of buydowns, savings, and ROI for increments of 10 bps or 25 bps.

3. **Time-Series Analysis**  
   - Track how the ROI of each buydown option changes over weeks, months, or years.

4. **Data Visualization**  
   - Present easy-to-understand charts showing ROI vs. coupon rate and ROI vs. time.

5. **AI-Driven Enhancements**  
   - **Data ingestion and cleaning**: Use AI to handle missing or outlier data in the daily price feed.  
   - **ROI forecasting**: Optionally train an AI model to predict how ROI might change under different market conditions.  
   - **Natural language querying**: Provide a chat-like interface (â€œWhatâ€™s the best buydown option for a 5% coupon on May 1st?â€) powered by a language model.

---

## 3. **Functional Requirements**

### 3.1 Data Collection & Management
2. **Data Storage**  
   - SQLite implementation at `mbs_data.db` with:
     - Compound primary key (date + coupon_rate) âœ”ï¸
     - Test dataset generation capability âœ”ï¸
     - Schema validation on write operations âœ”ï¸

3. **Data Cleaning & Validation**  
   - AI-based or rule-based methods to detect anomalies (e.g., sudden spikes from 95 to 110 in one day, or missing data).  
   - Fill or flag suspicious data points for review.

### 3.2 Calculation Engine
1. **Buydown Cost**  
   - For each daily data point, compute the cost to move from coupon rate \(r_1\) to \(r_2\).  
   - Optionally store these in increments of 10 bps or 25 bps.  
   - **Formula**:  
     \[
     \text{Buydown Cost} = (\text{Price}_{r_1} - \text{Price}_{r_2}) \times \text{Loan Amount}
     \]

2. **Monthly Savings**  
   - Compare mortgage payments at the original rate vs. the reduced rate.  
   - **Amortization formula** (30-year standard, or variable if needed):  
     \[
     \text{Monthly Payment} = \frac{r \times \text{Loan Amount}}{1 - (1 + r)^{-n}}
     \]  
     - \(r\) = monthly interest rate (annual rate / 12)  
     - \(n\) = total months (360 for 30 years)

3. **ROI**  
   - Annualize the monthly savings and divide by the upfront cost:  
     \[
     \text{ROI} = \frac{(\text{Monthly Savings} \times 12)}{\text{Buydown Cost}} \times 100\%
     \]

4. **Time-Series Analysis**  
   - Track these calculations across historical data (daily, weekly, monthly) to see how the ROI moves with market shifts.

### 3.3 Visualization
1. **UI Charts**  
   - **Chart A**: ROI vs. Coupon Rate for a given day  
     - X-axis: Coupon Rate  
     - Y-axis: ROI (%) or absolute cost  
   - **Chart B**: ROI vs. Time for a selected coupon rate or buydown increment  
     - X-axis: Date  
     - Y-axis: ROI (%)
   - **Chart C**: Cost Effectiveness vs. Time  
     - X-axis: Date  
     - Y-axis: Buydown Cost or cost per basis point

2. **Interactivity**  
   - Hover tooltips for data points.  
   - Filter by date range or coupon rate range.  
   - Export charts as PNG or PDF.

3. **AI-Enhanced Summaries**  
   - Optionally generate plain-English summaries: â€œOver the last 90 days, a buydown from 5% to 4.75% has averaged a 22% annualized ROI.â€

### 3.4 Reporting & Export
- **CSV/Excel Output**: For all calculations and ROI values so users can perform further offline analysis.  
- **PDF Reports**: Summaries with charts (monthly or weekly).  
- **AI-Powered Chat**: Allow a user to type questions like â€œWhich buydown increment had the highest ROI in February?â€ and return an automated, text-based answer generated by an LLM.

---

## 4. **Data Requirements**

4. **Buydown Increments**:
   - Implement 10 bps (0.10%) increments as primary analysis mode  
   - Example: 3.0% â†’ 2.90%, 2.80%, etc.  
   - (Note: 25 bps mode remains available for future comparative analysis)

---

## 5. **AI Integration Opportunities**

1. **Data Cleaning & Anomaly Detection**  
   - Use a simple regression or anomaly detection model (e.g., an LSTM or even a rules-based approach) to flag unrealistic jumps in MBS pricing.

2. **Predictive ROI Modeling**  
   - Train a regression model to estimate future pricing or future ROI based on historical data, macroeconomic indicators, or Fed announcements.

3. **Natural Language Query**  
   - Integrate a language model (e.g., OpenAI GPT or similar) to allow users to query data in plain English: â€œShow me the cost effectiveness of buying down from 5.5% to 5.0% over the last 6 months.â€

4. **Automated Code Generation**  
   - For repeated tasks (e.g., generating new visualization types), a code-generation LLM can expedite front-end or back-end scripts.

---

## 6. **User Interface / UX Requirements**

1. **Dashboard Page**  
   - **Historical ROI Chart**: Default view showing ROI across multiple coupon rates.  
   - **Custom Filtering**: Date range selector, coupon rates, increments of interest.

2. **Data Table**  
   - Display raw data (coupon rates, MBS prices, monthly savings, ROI).  
   - Sort/filter by ROI or by coupon rate.

3. **Interactive Chat (If Implemented)**  
   - Text box to enter queries in plain English.  
   - Return a text response and potentially filter or highlight relevant charts.

4. **Responsiveness**  
   - Ensure the layout works across desktop, tablet, and mobile screens.

---

## 7. **Technical Architecture**

### 7.1 High-Level Diagram

```
   [Data Sources]   ->   [AI Data Cleaning]   ->   [Database/Storage]   ->   [Calculation Engine]   ->   [Visualization + UI]
         |                                                                     ^                          |
         â””---------------------------(Fetch & Store)--------------------------â”˜                          |
                                                                                                          |
                                                                                   [AI Chat / Query] <----â”˜
```

### 7.2 Components
7. **Context Providers**  
   - Implemented in `context_providers.py`  
   - Required by NLU query system for real-time rate data  
   - Must be updated with actual data source integrations
5. **Testing Framework**  
   - pytest 8.3+ required for unit tests  
   - pytest-cov 4.1+ for coverage reporting  
   - python-dotenv 1.0+ for environment management

1. **Data Ingestion**  
   - Python 3.11.6 script using:  
     - `requests-html` for Mortgage News Daily scraping  
     - `pandas` for FRED API interaction (`fredapi` package)  
     - `sqlalchemy` for SQLite interaction

4. **Calculation Engine**  
   - Python 3.11.6 scripts with strict numerical validation  
   - 10 bps increment logic implemented in all ROI calculations

---

## 8. **Implementation Plan**

1. **Phase 1: Data Infrastructure & Basic Calculations** âœ… COMPLETED
   - Database setup âœ”ï¸ - SQLite schema with automated table creation **and operational imports**
   - Dual-source ingestion âœ”ï¸ - Real data collection via cron job
   - Test dataset generation âœ”ï¸ - Synthetic data validation implemented
   - Anomaly detection âœ”ï¸ - 5% daily price change threshold + test data verification
   - Unit tests âœ”ï¸ - Validation for calculation edge cases + SQL injection prevention

2. **Phase 2: Visualization & Front-End**  
   - **Step 5**: âœ… Matplotlib implementation complete  
     - Validated with synthetic test data âœ”ï¸  
     - 10bps increment visualization operational âœ”ï¸  
   - **Step 6**: âœ… Flask UI framework enhanced  
     - Chart export functionality implemented âœ”ï¸  
     - Time-series calculation accuracy improved âœ”ï¸  
     - Basic data tooltips via tables âœ”ï¸  
     - Remaining: Advanced hover tooltips âž”  

3. **Phase 3: AI Integration**  
   - **Step 7**: âœ… AI-enhanced anomaly detection  
     - Gemini integration tested âœ”ï¸  
     - Alerting system implemented âœ”ï¸  
     - Unit tests & sample data added âœ”ï¸  
   - **Step 8 (Optional)**: Build or integrate an LLM-based feature for natural language queries.  
   - **Step 9 (Optional)**: Add a forecasting model that predicts future ROI based on historical data.

4. **Phase 4: Testing & Refinement**  
   - **Step 10**: ðŸš§ Test data integrity & calculation correctness  
     - AI validation test cases âœ”ï¸  
     - NLU query response validation âž”  
   - **Step 11**: ðŸš§ User acceptance testing (UAT) preparation  
     - Test user onboarding checklist âž”  
   - **Step 12**: âŒ UI refinement pending UAT feedback

5. **Phase 5: Deployment & Maintenance**  
   - **Step 13**: Deploy the application (on a cloud service or local server).  
   - **Step 14**: Schedule the daily data update jobs.  
   - **Step 15**: Maintain code, update data sources, and incorporate new features as needed.

---

## 9. **Example Calculation & Visualization Code**

Below is a **sample** Python code snippet illustrating how you might structure your calculations and generate a simple chart in Matplotlib.

```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# Example data (in practice, fetch from your data sources or DB)
dates = pd.date_range(start='2025-01-01', periods=5, freq='D')
coupon_rates = [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]
# Example MBS prices for a single day (replace with actual data)
prices = [95, 96, 97, 98, 99, 100, 101, 102, 103]

loan_amount = 300000

# Compute buydown cost between adjacent coupon rates
# For a 0.5% difference in coupon, for instance:
price_diff = np.diff(prices)  # e.g. [1, 1, 1, 1, 1, 1, 1, 1]
buydown_costs = [diff * loan_amount for diff in price_diff]

# Placeholder monthly savings calculation (replace with real amortization logic)
# e.g., monthly payment at 5% minus monthly payment at 4.5%
monthly_savings_example = [50, 60, 70, 80, 90, 100, 110]  # sample values

# ROI: (Monthly Savings x 12) / Buydown Cost x 100%
roi_values = []
for i, cost in enumerate(buydown_costs):
    # Ensure cost is not zero or negative
    if cost > 0 and i < len(monthly_savings_example):
        annual_savings = monthly_savings_example[i] * 12
        roi = (annual_savings / cost) * 100
        roi_values.append(roi)
    else:
        roi_values.append(None)

# Plot ROI vs. Coupon Rate
x_values = coupon_rates[:-1]  # one less than the length because we're using adjacent differences
plt.figure(figsize=(8, 6))
plt.plot(x_values, roi_values, marker='o', label='ROI (%)')
plt.title('ROI vs. Coupon Rate')
plt.xlabel('Coupon Rate (%)')
plt.ylabel('ROI (%)')
plt.grid(True)
plt.legend()
plt.show()
```

---

## 10. **Non-Functional Requirements**

1. **Performance**  
   - Daily data retrieval and ROI calculations should complete in under a minute for typical usage.

2. **Scalability**  
   - The solution should easily accommodate more coupon rate granularity or new data sources without redesign.

3. **Security & Privacy**  
   - If user data or personal mortgage info is stored, ensure basic encryption or standard security practices.

4. **Reliability**  
   - Scheduled tasks must run consistently to keep the data current.

---

## 11. **Testing**

Add new subsection:

### 11.4 Synthetic Data Validation
- All visualization features must pass synthetic data checks before real data integration
- Test dataset characteristics:
  ```python
  {
      'date': '2024-05-01',
      'coupon_rates': [3.0, 3.5, ..., 7.0],  # 0.5% increments
      'prices': [95.5, 96.0, ..., 99.5]      # Linear progression
  }
```

---

## 12. **Risks & Mitigations**

1. **Data Availability**  
   - Mitigation: Implement fallback data sources; store historical data so short-term outages donâ€™t break the system.

2. **Data Accuracy**  
   - Mitigation: AI-based or rule-based anomaly checks; manual overrides for flagged entries.

3. **Market Volatility**  
   - Mitigation: Provide disclaimers that ROI predictions are based on past performance and canâ€™t guarantee future results.

4. **Complexity of Implementation**  
   - Mitigation: Start with a minimum viable product (MVP) that focuses on daily ingestion and basic ROI charts; expand with AI features iteratively.

---

## 13. **Milestones & Timeline**

| Phase                   | Tasks                                          | Estimated Duration |
|-------------------------|-----------------------------------------------|--------------------|
| **Phase 1**            | Data ingestion, storage, ROI calculations     | 1-2 Weeks         |
| **Phase 2**            | Basic UI & Visualization                       | 1-2 Weeks         |
| **Phase 3**            | AI integration (anomaly detection, chat)       | 2-4 Weeks         |
| **Phase 4**            | Testing, Refinement, UAT                       | 1-2 Weeks         |
| **Phase 4**            | 8.4 Phase 4 Critical Path
- [ ] Replace all placeholder data in context_providers.py
- [ ] Add environment validation checks for:
  - Database connection
  - API keys
  - Calculation thresholds
- [ ] Implement missing historical context federation actions
- [ ] Validate ROI calculation signatures against test expectations
   - **Phase 5**            | Deployment & Maintenance                       | Ongoing           |

---

## 14. **Future Enhancements**

- **Scenario Analysis**: Let users run â€œwhat-ifâ€ scenarios (e.g., â€œWhat if rates shift up 0.5% next month?â€).  
- **Refinancing Scenarios**: Integrate a refinancing model to see if a buydown or refi is more cost-effective.  
- **Deeper AI Forecasting**: Use machine learning to predict MBS prices or mortgage rate movements.  
- **Mobile App**: Wrap the web application in a mobile-friendly interface or native mobile app.

---

## 15. **Conclusion**

This PRD outlines a clear, step-by-step plan to build a Mortgage Rate Buydown Analyzer. By incorporating:

1. **Structured Data Ingestion**  
2. **Automated Calculations**  
3. **Intuitive Visualizations**  
4. **AI Enhancements** (data cleaning, ROI forecasting, natural language queries)

â€¦we can deliver a robust solution that helps users understand the relative cost-effectiveness of buying down mortgage rates. 

Should you need further clarity on any of these pointsâ€”especially around data sourcing, calculation details, or AI model selectionâ€”this PRD provides a solid foundation to guide ongoing discussions and development efforts.